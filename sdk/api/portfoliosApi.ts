import { PropertyValue } from '../model/propertyValue';
/**
 * LUSID API
 * # Introduction  This page documents the [LUSID APIs](https://www.lusid.com/api/swagger), which allows authorised clients to query and update their data within the LUSID platform.  SDKs to interact with the LUSID APIs are available in the following languages and frameworks:  * [C#](https://github.com/finbourne/lusid-sdk-csharp) * [Java](https://github.com/finbourne/lusid-sdk-java) * [JavaScript](https://github.com/finbourne/lusid-sdk-js) * [Python](https://github.com/finbourne/lusid-sdk-python) * [Angular](https://github.com/finbourne/lusid-sdk-angular)  The LUSID platform is made up of a number of sub-applications. You can find the API / swagger documentation by following the links in the table below.   | Application | Description | API / Swagger Documentation | | ----- | ----- | ---- | | LUSID | Open, API-first, developer-friendly investment data platform. | [Swagger](https://www.lusid.com/api/swagger/index.html) | | Web app | User-facing front end for LUSID. | [Swagger](https://www.lusid.com/app/swagger/index.html) | | Scheduler | Automated job scheduler. | [Swagger](https://www.lusid.com/scheduler2/swagger/index.html) | | Insights |Monitoring and troubleshooting service. | [Swagger](https://www.lusid.com/insights/swagger/index.html) | | Identity | Identity management for LUSID (in conjuction with Access) | [Swagger](https://www.lusid.com/identity/swagger/index.html) | | Access | Access control for LUSID (in conjunction with Identity) | [Swagger](https://www.lusid.com/access/swagger/index.html) | | Drive | Secure file repository and manager for collaboration. | [Swagger](https://www.lusid.com/drive/swagger/index.html) | | Luminesce | Data virtualisation service (query data from multiple providers, including LUSID) | [Swagger](https://www.lusid.com/honeycomb/swagger/index.html) | | Notification | Notification service. | [Swagger](https://www.lusid.com/notifications/swagger/index.html) | | Configuration | File store for secrets and other sensitive information. | [Swagger](https://www.lusid.com/configuration/swagger/index.html) | 
 *
 * The version of the OpenAPI document: 0.11.3428
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { AccessMetadataValue } from '../model/accessMetadataValue';
import { DeletedEntityResponse } from '../model/deletedEntityResponse';
import { LusidProblemDetails } from '../model/lusidProblemDetails';
import { LusidValidationProblemDetails } from '../model/lusidValidationProblemDetails';
import { PerformanceReturn } from '../model/performanceReturn';
import { Portfolio } from '../model/portfolio';
import { PortfolioProperties } from '../model/portfolioProperties';
import { Property } from '../model/property';
import { ResourceListOfAccessMetadataValueOf } from '../model/resourceListOfAccessMetadataValueOf';
import { ResourceListOfAggregatedReturn } from '../model/resourceListOfAggregatedReturn';
import { ResourceListOfPerformanceReturn } from '../model/resourceListOfPerformanceReturn';
import { ResourceListOfPortfolio } from '../model/resourceListOfPortfolio';
import { ResourceListOfProcessedCommand } from '../model/resourceListOfProcessedCommand';
import { ResourceListOfProperty } from '../model/resourceListOfProperty';
import { ResourceListOfPropertyInterval } from '../model/resourceListOfPropertyInterval';
import { ResourceListOfRelation } from '../model/resourceListOfRelation';
import { ResourceListOfRelationship } from '../model/resourceListOfRelationship';
import { UpdatePortfolioRequest } from '../model/updatePortfolioRequest';
import { UpsertPortfolioAccessMetadataRequest } from '../model/upsertPortfolioAccessMetadataRequest';
import { UpsertReturnsResponse } from '../model/upsertReturnsResponse';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/models';
import { OAuth } from '../model/models';

let defaultBasePath = 'http://local-unit-test-server.lusid.com:39100';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum PortfoliosApiApiKeys {
}

export class PortfoliosApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: PortfoliosApiApiKeys, value: string) {
        (this.authentications as any)[PortfoliosApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }

    /**
     * Delete the Portfolio Access Metadata Rule that exactly matches the provided identifier parts
     * @summary [EXPERIMENTAL] Delete a Portfolio Access Metadata Rule
     * @param scope The scope of the Quote Access Metadata Rule to retrieve.
     * @param code Portfolio code
     * @param metadataKey The metadataKey identifying the access metadata entry to delete
     * @param effectiveAt The effective date to delete at, if this is not supplied, it will delete all data found
     */
    public async deleteKeyFromPortfolioAccessMetadata (scope: string, code: string, metadataKey: string, effectiveAt?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedEntityResponse;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/metadata/{metadataKey}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'metadataKey' + '}', encodeURIComponent(String(metadataKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling deleteKeyFromPortfolioAccessMetadata.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteKeyFromPortfolioAccessMetadata.');
        }

        // verify required parameter 'metadataKey' is not null or undefined
        if (metadataKey === null || metadataKey === undefined) {
            throw new Error('Required parameter metadataKey was null or undefined when calling deleteKeyFromPortfolioAccessMetadata.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeletedEntityResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeletedEntityResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a particular portfolio.                The deletion will take effect from the portfolio\'s creation datetime. This means that the portfolio will no longer exist at any effective datetime, as per the asAt datetime of deletion.
     * @summary Delete portfolio
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     */
    public async deletePortfolio (scope: string, code: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedEntityResponse;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling deletePortfolio.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deletePortfolio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeletedEntityResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeletedEntityResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete one or more properties from a particular portfolio. If the properties are time-variant then an effective datetime from which  to delete properties must be specified. If the properties are perpetual then it is invalid to specify an effective datetime for deletion.
     * @summary Delete portfolio properties
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param propertyKeys The property keys of the properties to delete. These must take the format              {domain}/{scope}/{code}, for example \&#39;Portfolio/Manager/Id\&#39;. Each property must be from the \&#39;Portfolio\&#39; domain.
     * @param effectiveAt The effective datetime or cut label at which to delete time-variant properties.
     */
    public async deletePortfolioProperties (scope: string, code: string, propertyKeys: Array<string>, effectiveAt?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedEntityResponse;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/properties'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling deletePortfolioProperties.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deletePortfolioProperties.');
        }

        // verify required parameter 'propertyKeys' is not null or undefined
        if (propertyKeys === null || propertyKeys === undefined) {
            throw new Error('Required parameter propertyKeys was null or undefined when calling deletePortfolioProperties.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (propertyKeys !== undefined) {
            localVarQueryParameters['propertyKeys'] = ObjectSerializer.serialize(propertyKeys, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeletedEntityResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeletedEntityResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancel one or more Returns which exist into the specified portfolio.
     * @summary [EXPERIMENTAL] Delete Returns
     * @param scope The scope of the Portfolio.
     * @param code The code of the  Portfolio.
     * @param returnScope The scope of the Returns.
     * @param returnCode The code of the Returns.
     * @param fromEffectiveAt The start date from which to delete the Returns.
     * @param toEffectiveAt The end date from which to delete the Returns.
     * @param period The Period (Daily or Monthly) of the Returns to be deleted.
     */
    public async deletePortfolioReturns (scope: string, code: string, returnScope: string, returnCode: string, fromEffectiveAt: string, toEffectiveAt: string, period?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedEntityResponse;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/returns/{returnScope}/{returnCode}/$delete'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'returnScope' + '}', encodeURIComponent(String(returnScope)))
            .replace('{' + 'returnCode' + '}', encodeURIComponent(String(returnCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling deletePortfolioReturns.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deletePortfolioReturns.');
        }

        // verify required parameter 'returnScope' is not null or undefined
        if (returnScope === null || returnScope === undefined) {
            throw new Error('Required parameter returnScope was null or undefined when calling deletePortfolioReturns.');
        }

        // verify required parameter 'returnCode' is not null or undefined
        if (returnCode === null || returnCode === undefined) {
            throw new Error('Required parameter returnCode was null or undefined when calling deletePortfolioReturns.');
        }

        // verify required parameter 'fromEffectiveAt' is not null or undefined
        if (fromEffectiveAt === null || fromEffectiveAt === undefined) {
            throw new Error('Required parameter fromEffectiveAt was null or undefined when calling deletePortfolioReturns.');
        }

        // verify required parameter 'toEffectiveAt' is not null or undefined
        if (toEffectiveAt === null || toEffectiveAt === undefined) {
            throw new Error('Required parameter toEffectiveAt was null or undefined when calling deletePortfolioReturns.');
        }

        if (fromEffectiveAt !== undefined) {
            localVarQueryParameters['fromEffectiveAt'] = ObjectSerializer.serialize(fromEffectiveAt, "string");
        }

        if (toEffectiveAt !== undefined) {
            localVarQueryParameters['toEffectiveAt'] = ObjectSerializer.serialize(toEffectiveAt, "string");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeletedEntityResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeletedEntityResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the definition of a particular portfolio.
     * @summary Get portfolio
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param effectiveAt The effective datetime or cut label at which to retrieve the portfolio definition. Defaults to the current LUSID system datetime if not specified.
     * @param asAt The asAt datetime at which to retrieve the portfolio definition. Defaults to returning the latest version of the portfolio definition if not specified.
     * @param propertyKeys A list of property keys from the \&#39;Portfolio\&#39; domain to decorate onto the portfolio.              These must take the format {domain}/{scope}/{code}, for example \&#39;Portfolio/Manager/Id\&#39;.
     */
    public async getPortfolio (scope: string, code: string, effectiveAt?: string, asAt?: Date, propertyKeys?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Portfolio;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolio.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolio.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        if (propertyKeys !== undefined) {
            localVarQueryParameters['propertyKeys'] = ObjectSerializer.serialize(propertyKeys, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Portfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Aggregate Returns which are on the specified portfolio.
     * @summary [EXPERIMENTAL] Aggregate Returns
     * @param scope The scope of the Portfolio.
     * @param code The code of the  Portfolio.
     * @param returnScope The scope of the Returns.
     * @param returnCode The code of the Returns.
     * @param recipeIdScope The Recipe Scope for getting the fx rates
     * @param recipeIdCode The Recipe Code for getting the fx rates
     * @param fromEffectiveAt The start date from which to calculate the Returns.
     * @param toEffectiveAt The end date for which to calculate the Returns.
     * @param compositeMethod The method used to calculate the Portfolio performance:              Equal/Asset.
     * @param period The type of the returns used to calculate the aggregation result: Daily/Monthly.
     * @param outputFrequency The type of calculated output: Daily/Weekly/Monthly/Quarterly/Half-Yearly/Yearly.
     * @param metrics Determines what type of returns should be calculated, see https://support.lusid.com/knowledgebase/article/KA-01675/en-us for a list of available metrics.
     * @param asAt The asAt datetime at which to retrieve the Returns. Defaults to the latest.
     */
    public async getPortfolioAggregateReturns (scope: string, code: string, returnScope: string, returnCode: string, recipeIdScope?: string, recipeIdCode?: string, fromEffectiveAt?: string, toEffectiveAt?: string, compositeMethod?: string, period?: string, outputFrequency?: string, metrics?: Array<string>, asAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfAggregatedReturn;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/returns/{returnScope}/{returnCode}/aggregated'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'returnScope' + '}', encodeURIComponent(String(returnScope)))
            .replace('{' + 'returnCode' + '}', encodeURIComponent(String(returnCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolioAggregateReturns.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolioAggregateReturns.');
        }

        // verify required parameter 'returnScope' is not null or undefined
        if (returnScope === null || returnScope === undefined) {
            throw new Error('Required parameter returnScope was null or undefined when calling getPortfolioAggregateReturns.');
        }

        // verify required parameter 'returnCode' is not null or undefined
        if (returnCode === null || returnCode === undefined) {
            throw new Error('Required parameter returnCode was null or undefined when calling getPortfolioAggregateReturns.');
        }

        if (recipeIdScope !== undefined) {
            localVarQueryParameters['recipeIdScope'] = ObjectSerializer.serialize(recipeIdScope, "string");
        }

        if (recipeIdCode !== undefined) {
            localVarQueryParameters['recipeIdCode'] = ObjectSerializer.serialize(recipeIdCode, "string");
        }

        if (fromEffectiveAt !== undefined) {
            localVarQueryParameters['fromEffectiveAt'] = ObjectSerializer.serialize(fromEffectiveAt, "string");
        }

        if (toEffectiveAt !== undefined) {
            localVarQueryParameters['toEffectiveAt'] = ObjectSerializer.serialize(toEffectiveAt, "string");
        }

        if (compositeMethod !== undefined) {
            localVarQueryParameters['compositeMethod'] = ObjectSerializer.serialize(compositeMethod, "string");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "string");
        }

        if (outputFrequency !== undefined) {
            localVarQueryParameters['outputFrequency'] = ObjectSerializer.serialize(outputFrequency, "string");
        }

        if (metrics !== undefined) {
            localVarQueryParameters['metrics'] = ObjectSerializer.serialize(metrics, "Array<string>");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfAggregatedReturn;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfAggregatedReturn");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the commands that modified a particular portfolio, including any input transactions.
     * @summary [EARLY ACCESS] Get portfolio commands
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param fromAsAt The lower bound asAt datetime (inclusive) from which to retrieve commands. There is no lower bound if this is not specified.
     * @param toAsAt The upper bound asAt datetime (inclusive) from which to retrieve commands. There is no upper bound if this is not specified.
     * @param filter Expression to filter the results.              For example, to filter on the User ID, specify \&quot;userId.id eq \&#39;string\&#39;\&quot;.              For more information about filtering, see https://support.lusid.com/knowledgebase/article/KA-01914.
     * @param page The pagination token to use to continue listing commands; this value is returned from the previous call.
     * @param limit When paginating, limit the results to this number. Defaults to 500 if not specified.
     */
    public async getPortfolioCommands (scope: string, code: string, fromAsAt?: Date, toAsAt?: Date, filter?: string, page?: string, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfProcessedCommand;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/commands'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolioCommands.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolioCommands.');
        }

        if (fromAsAt !== undefined) {
            localVarQueryParameters['fromAsAt'] = ObjectSerializer.serialize(fromAsAt, "Date");
        }

        if (toAsAt !== undefined) {
            localVarQueryParameters['toAsAt'] = ObjectSerializer.serialize(toAsAt, "Date");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfProcessedCommand;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfProcessedCommand");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Pass the scope and portfolio code parameters to retrieve the AccessMetadata associated with a portfolio
     * @summary [EXPERIMENTAL] Get access metadata rules for a portfolio
     * @param scope The scope of the Portfolio Access Metadata Rule to retrieve.
     * @param code Portfolio code
     * @param effectiveAt The effectiveAt datetime at which to retrieve the access metadata rule.
     * @param asAt The asAt datetime at which to retrieve the portfolio access metadata.
     */
    public async getPortfolioMetadata (scope: string, code: string, effectiveAt?: string, asAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: { [key: string]: Array<AccessMetadataValue>; };  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/metadata'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolioMetadata.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolioMetadata.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: Array<AccessMetadataValue>; };  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: Array<AccessMetadataValue>; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all the properties of a particular portfolio.
     * @summary Get portfolio properties
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param effectiveAt The effective datetime or cut label at which to list the portfolio\&#39;s properties. Defaults to the current LUSID system datetime if not specified.
     * @param asAt The asAt datetime at which to list the portfolio\&#39;s properties. Defaults to returning the latest version of each property if not specified.
     */
    public async getPortfolioProperties (scope: string, code: string, effectiveAt?: string, asAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PortfolioProperties;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/properties'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolioProperties.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolioProperties.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PortfolioProperties;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioProperties");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show the complete time series (history) for a particular portfolio property.
     * @summary [EXPERIMENTAL] Get portfolio property time series
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param propertyKey The property key of the property whose history to show.              This must be from the \&#39;Portfolio\&#39; domain and in the format {domain}/{scope}/{code}, for example \&#39;Portfolio/Manager/Id\&#39;.
     * @param portfolioEffectiveAt The effective datetime used to resolve the portfolio. Defaults to the current LUSID system datetime if not specified.
     * @param asAt The asAt datetime at which to show the history. Defaults to returning the current datetime if not supplied.
     * @param filter Expression to filter the results. For more information about filtering,              see https://support.lusid.com/knowledgebase/article/KA-01914.
     * @param page The pagination token to use to continue listing properties; this value is returned from              the previous call. If a pagination token is provided, the filter, portfolioEffectiveAt, and asAt fields              must not have changed since the original request.
     * @param limit When paginating, limit the results to this number.
     */
    public async getPortfolioPropertyTimeSeries (scope: string, code: string, propertyKey?: string, portfolioEffectiveAt?: string, asAt?: Date, filter?: string, page?: string, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfPropertyInterval;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/properties/time-series'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolioPropertyTimeSeries.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolioPropertyTimeSeries.');
        }

        if (propertyKey !== undefined) {
            localVarQueryParameters['propertyKey'] = ObjectSerializer.serialize(propertyKey, "string");
        }

        if (portfolioEffectiveAt !== undefined) {
            localVarQueryParameters['portfolioEffectiveAt'] = ObjectSerializer.serialize(portfolioEffectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfPropertyInterval;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfPropertyInterval");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get relations for a particular portfolio.
     * @summary [EXPERIMENTAL] Get portfolio relations
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param effectiveAt The effective datetime or cut label at which to retrieve relations. Defaults to the current LUSID system datetime if not specified.
     * @param asAt The asAt datetime at which to retrieve relations. Defaults to returning the latest LUSID AsAt time if not specified.
     * @param filter Expression to filter the relations. Provide a null or empty string for this field until further notice.
     * @param identifierTypes Identifier types (as property keys) used for referencing Persons or Legal Entities.              These must be from the \&#39;Person\&#39; or \&#39;LegalEntity\&#39; domains and have the format {domain}/{scope}/{code}, for example              \&#39;Person/CompanyDetails/Role\&#39;. Only identifier types provided will be used to look up relevant entities in relations. If not applicable, provide an empty array.
     */
    public async getPortfolioRelations (scope: string, code: string, effectiveAt?: string, asAt?: Date, filter?: string, identifierTypes?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfRelation;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/relations'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolioRelations.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolioRelations.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (identifierTypes !== undefined) {
            localVarQueryParameters['identifierTypes'] = ObjectSerializer.serialize(identifierTypes, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get relationships for a particular portfolio.
     * @summary [EXPERIMENTAL] Get portfolio relationships
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param effectiveAt The effective datetime or cut label at which to retrieve relationships. Defaults to the current LUSID system datetime if not specified.
     * @param asAt The asAt datetime at which to retrieve relationships. Defaults to returning the latest LUSID AsAt time if not specified.
     * @param filter Expression to filter the relationships. Provide a null or empty string for this field until further notice.
     * @param identifierTypes Identifier types (as property keys) used for referencing Persons or Legal Entities.              These must be from the \&#39;Person\&#39; or \&#39;LegalEntity\&#39; domains and have the format {domain}/{scope}/{code}, for example              \&#39;Person/CompanyDetails/Role\&#39;. Only identifier types provided will be used to look up relevant entities in relationships. If not applicable, provide an empty array.
     */
    public async getPortfolioRelationships (scope: string, code: string, effectiveAt?: string, asAt?: Date, filter?: string, identifierTypes?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfRelationship;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/relationships'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolioRelationships.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolioRelationships.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (identifierTypes !== undefined) {
            localVarQueryParameters['identifierTypes'] = ObjectSerializer.serialize(identifierTypes, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfRelationship;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfRelationship");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Returns which are on the specified portfolio.
     * @summary [EARLY ACCESS] Get Returns
     * @param scope The scope of the Portfolio.
     * @param code The code of the  Portfolio.
     * @param returnScope The scope of the Returns.
     * @param returnCode The code of the Returns.
     * @param fromEffectiveAt The start date from which to get the Returns.
     * @param toEffectiveAt The end date from which to get the Returns.
     * @param period Show the Returns on a Daily or Monthly period.
     * @param asAt The asAt datetime at which to retrieve the Returns. Defaults to the latest.
     */
    public async getPortfolioReturns (scope: string, code: string, returnScope: string, returnCode: string, fromEffectiveAt?: string, toEffectiveAt?: string, period?: string, asAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfPerformanceReturn;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/returns/{returnScope}/{returnCode}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'returnScope' + '}', encodeURIComponent(String(returnScope)))
            .replace('{' + 'returnCode' + '}', encodeURIComponent(String(returnCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfolioReturns.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfolioReturns.');
        }

        // verify required parameter 'returnScope' is not null or undefined
        if (returnScope === null || returnScope === undefined) {
            throw new Error('Required parameter returnScope was null or undefined when calling getPortfolioReturns.');
        }

        // verify required parameter 'returnCode' is not null or undefined
        if (returnCode === null || returnCode === undefined) {
            throw new Error('Required parameter returnCode was null or undefined when calling getPortfolioReturns.');
        }

        if (fromEffectiveAt !== undefined) {
            localVarQueryParameters['fromEffectiveAt'] = ObjectSerializer.serialize(fromEffectiveAt, "string");
        }

        if (toEffectiveAt !== undefined) {
            localVarQueryParameters['toEffectiveAt'] = ObjectSerializer.serialize(toEffectiveAt, "string");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfPerformanceReturn;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfPerformanceReturn");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a specific portfolio access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
     * @summary [EXPERIMENTAL] Get an entry identified by a metadataKey in the access metadata object
     * @param scope The scope of the Portfolio Access Metadata Rule to retrieve.
     * @param code The code of the portfolio
     * @param metadataKey Key of the metadata to retrieve
     * @param effectiveAt The effective date of the rule
     * @param asAt The asAt datetime at which to retrieve the portfolio access metadata.
     */
    public async getPortfoliosAccessMetadataByKey (scope: string, code: string, metadataKey: string, effectiveAt?: string, asAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AccessMetadataValue>;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/metadata/{metadataKey}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'metadataKey' + '}', encodeURIComponent(String(metadataKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getPortfoliosAccessMetadataByKey.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPortfoliosAccessMetadataByKey.');
        }

        // verify required parameter 'metadataKey' is not null or undefined
        if (metadataKey === null || metadataKey === undefined) {
            throw new Error('Required parameter metadataKey was null or undefined when calling getPortfoliosAccessMetadataByKey.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AccessMetadataValue>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AccessMetadataValue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all the properties of a particular portfolio.
     * @summary [EXPERIMENTAL] Get portfolio properties
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param effectiveAt The effective datetime or cut label at which to list the portfolio\&#39;s properties. Defaults to the current LUSID system datetime if not specified.
     * @param asAt The asAt datetime at which to list the portfolio\&#39;s properties. Defaults to returning the latest version of each property if not specified.
     * @param page The pagination token to use to continue listing commands; this value is returned from the previous call.
     * @param limit When paginating, limit the results per page to this number.
     */
    public async listPortfolioProperties (scope: string, code: string, effectiveAt?: string, asAt?: Date, page?: string, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfProperty;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/properties/list'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling listPortfolioProperties.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling listPortfolioProperties.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfProperty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfProperty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all the portfolios matching particular criteria.
     * @summary List portfolios
     * @param effectiveAt The effective datetime or cut label at which to list the portfolios. Defaults to the current LUSID              system datetime if not specified.
     * @param asAt The asAt datetime at which to list the portfolios. Defaults to returning the latest version              of each portfolio if not specified.
     * @param page The pagination token to use to continue listing portfolios; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided.
     * @param start When paginating, skip this number of results.
     * @param limit When paginating, limit the results to this number. Defaults to 65,535 if not specified.
     * @param filter Expression to filter the results.              For example, to filter on the transaction type, specify \&quot;type eq \&#39;Transaction\&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
     * @param query Expression specifying the criteria that the returned portfolios must meet. For example, to see which              portfolios have holdings in instruments with a LusidInstrumentId (LUID) of \&#39;LUID_PPA8HI6M\&#39; or a Figi of \&#39;BBG000BLNNH6\&#39;,              specify \&quot;instrument.identifiers in ((\&#39;LusidInstrumentId\&#39;, \&#39;LUID_PPA8HI6M\&#39;), (\&#39;Figi\&#39;, \&#39;BBG000BLNNH6\&#39;))\&quot;.
     * @param propertyKeys A list of property keys from the \&#39;Portfolio\&#39; domain to decorate onto each portfolio.              These must take the format {domain}/{scope}/{code}, for example \&#39;Portfolio/Manager/Id\&#39;.
     */
    public async listPortfolios (effectiveAt?: string, asAt?: Date, page?: string, start?: number, limit?: number, filter?: string, query?: string, propertyKeys?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfPortfolio;  }> {
        const localVarPath = this.basePath + '/api/portfolios';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (propertyKeys !== undefined) {
            localVarQueryParameters['propertyKeys'] = ObjectSerializer.serialize(propertyKeys, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfPortfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfPortfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all the portfolios in a particular scope.
     * @summary List portfolios for scope
     * @param scope The scope whose portfolios to list.
     * @param effectiveAt The effective datetime or cut label at which to list the portfolios. Defaults to the current LUSID              system datetime if not specified.
     * @param asAt The asAt datetime at which to list the portfolios. Defaults to returning the latest version              of each portfolio if not specified.
     * @param page The pagination token to use to continue listing portfolios. This  value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided.
     * @param start When paginating, skip this number of results.
     * @param limit When paginating, limit the results to this number. Defaults to 65,535 if not specified.
     * @param filter Expression to filter the results.              For example, to return only transactions with a transaction type of \&#39;Buy\&#39;, specify \&quot;type eq \&#39;Buy\&#39;\&quot;.              For more information about filtering results, see https://support.lusid.com/knowledgebase/article/KA-01914.
     * @param propertyKeys A list of property keys from the \&#39;Portfolio\&#39; domain to decorate onto each portfolio.              These must take the format {domain}/{scope}/{code}, for example \&#39;Portfolio/Manager/Id\&#39;.
     */
    public async listPortfoliosForScope (scope: string, effectiveAt?: string, asAt?: Date, page?: string, start?: number, limit?: number, filter?: string, propertyKeys?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfPortfolio;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling listPortfoliosForScope.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        if (asAt !== undefined) {
            localVarQueryParameters['asAt'] = ObjectSerializer.serialize(asAt, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (propertyKeys !== undefined) {
            localVarQueryParameters['propertyKeys'] = ObjectSerializer.serialize(propertyKeys, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfPortfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfPortfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the definition of a particular portfolio.                Note that not all elements of a portfolio definition are  modifiable due to the potential implications for data already stored.
     * @summary Update portfolio
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param updatePortfolioRequest The updated portfolio definition.
     * @param effectiveAt The effective datetime or cut label at which to update the definition. Defaults to the current               LUSID system datetime if not specified.
     */
    public async updatePortfolio (scope: string, code: string, updatePortfolioRequest: UpdatePortfolioRequest, effectiveAt?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Portfolio;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling updatePortfolio.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updatePortfolio.');
        }

        // verify required parameter 'updatePortfolioRequest' is not null or undefined
        if (updatePortfolioRequest === null || updatePortfolioRequest === undefined) {
            throw new Error('Required parameter updatePortfolioRequest was null or undefined when calling updatePortfolio.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updatePortfolioRequest, "UpdatePortfolioRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Portfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update or insert one Portfolio Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Portfolio Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
     * @summary [EXPERIMENTAL] Upsert a Portfolio Access Metadata Rule associated with specific metadataKey. This creates or updates the data in LUSID.
     * @param scope The scope to use when updating or inserting the Portfolio Access Metadata Rule.
     * @param code Portfolio code
     * @param metadataKey Key of the access metadata to upsert
     * @param upsertPortfolioAccessMetadataRequest The Portfolio Access Metadata Rule to update or insert
     * @param effectiveAt The date this rule will effective from
     */
    public async upsertPortfolioAccessMetadata (scope: string, code: string, metadataKey: string, upsertPortfolioAccessMetadataRequest: UpsertPortfolioAccessMetadataRequest, effectiveAt?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ResourceListOfAccessMetadataValueOf;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/metadata/{metadataKey}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'metadataKey' + '}', encodeURIComponent(String(metadataKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling upsertPortfolioAccessMetadata.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling upsertPortfolioAccessMetadata.');
        }

        // verify required parameter 'metadataKey' is not null or undefined
        if (metadataKey === null || metadataKey === undefined) {
            throw new Error('Required parameter metadataKey was null or undefined when calling upsertPortfolioAccessMetadata.');
        }

        // verify required parameter 'upsertPortfolioAccessMetadataRequest' is not null or undefined
        if (upsertPortfolioAccessMetadataRequest === null || upsertPortfolioAccessMetadataRequest === undefined) {
            throw new Error('Required parameter upsertPortfolioAccessMetadataRequest was null or undefined when calling upsertPortfolioAccessMetadata.');
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effectiveAt'] = ObjectSerializer.serialize(effectiveAt, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(upsertPortfolioAccessMetadataRequest, "UpsertPortfolioAccessMetadataRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResourceListOfAccessMetadataValueOf;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourceListOfAccessMetadataValueOf");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create or update one or more properties for a particular portfolio. A property is updated if it  already exists and created if it does not. All properties must be from the \'Portfolio\' domain.                Properties have an <i>effectiveFrom</i> datetime from which the property is valid, and an <i>effectiveUntil</i>  datetime until which it is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.
     * @summary Upsert portfolio properties
     * @param scope The scope of the portfolio.
     * @param code The code of the portfolio. Together with the scope this uniquely identifies the portfolio.
     * @param requestBody The properties to be created or updated. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code}, for example               \&#39;Portfolio/Manager/Id\&#39;.
     */
    public async upsertPortfolioProperties (scope: string, code: string, requestBody: { [key: string]: Property; }, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PortfolioProperties;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/properties'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling upsertPortfolioProperties.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling upsertPortfolioProperties.');
        }

        // verify required parameter 'requestBody' is not null or undefined
        if (requestBody === null || requestBody === undefined) {
            throw new Error('Required parameter requestBody was null or undefined when calling upsertPortfolioProperties.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestBody, "{ [key: string]: Property; }")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PortfolioProperties;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioProperties");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update or insert returns into the specified portfolio.
     * @summary [EARLY ACCESS] Upsert Returns
     * @param scope The scope of the Portfolio.
     * @param code The code of the  Portfolio.
     * @param returnScope The scope of the Returns.
     * @param returnCode The code of the Returns.
     * @param performanceReturn This contains the Returns which need to be upsert.
     */
    public async upsertPortfolioReturns (scope: string, code: string, returnScope: string, returnCode: string, performanceReturn: Array<PerformanceReturn>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UpsertReturnsResponse;  }> {
        const localVarPath = this.basePath + '/api/portfolios/{scope}/{code}/returns/{returnScope}/{returnCode}'
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'returnScope' + '}', encodeURIComponent(String(returnScope)))
            .replace('{' + 'returnCode' + '}', encodeURIComponent(String(returnCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling upsertPortfolioReturns.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling upsertPortfolioReturns.');
        }

        // verify required parameter 'returnScope' is not null or undefined
        if (returnScope === null || returnScope === undefined) {
            throw new Error('Required parameter returnScope was null or undefined when calling upsertPortfolioReturns.');
        }

        // verify required parameter 'returnCode' is not null or undefined
        if (returnCode === null || returnCode === undefined) {
            throw new Error('Required parameter returnCode was null or undefined when calling upsertPortfolioReturns.');
        }

        // verify required parameter 'performanceReturn' is not null or undefined
        if (performanceReturn === null || performanceReturn === undefined) {
            throw new Error('Required parameter performanceReturn was null or undefined when calling upsertPortfolioReturns.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(performanceReturn, "Array<PerformanceReturn>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UpsertReturnsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpsertReturnsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
